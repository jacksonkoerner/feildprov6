<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Drafts & Pending Reports - FieldVoice Pro</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./assets/apple-touch-icon.png">
    <meta name="theme-color" content="#0a1628">

    <!-- iOS PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FieldVoice">

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./js/config.js"></script>
    <script src="./js/pwa-utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'dot-navy': '#0a1628',
                        'dot-blue': '#1e3a5f',
                        'dot-slate': '#334155',
                        'dot-orange': '#ea580c',
                        'dot-yellow': '#f59e0b',
                        'safety-green': '#16a34a',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        .header-stripe {
            background: repeating-linear-gradient(
                -45deg,
                #f59e0b,
                #f59e0b 10px,
                #0a1628 10px,
                #0a1628 20px
            );
            height: 4px;
            padding-top: env(safe-area-inset-top);
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen">
    <!-- Safety Stripe Header -->
    <div class="header-stripe"></div>

    <!-- Online Sync Banner -->
    <div id="syncBanner" class="hidden bg-safety-green text-white cursor-pointer" onclick="syncAllPending()">
        <div class="max-w-lg mx-auto px-4 py-3 flex items-center gap-3">
            <i class="fas fa-cloud-upload-alt"></i>
            <p class="flex-1 text-sm font-medium">You have pending reports. Tap to sync.</p>
            <i class="fas fa-chevron-right"></i>
        </div>
    </div>

    <div id="app" class="max-w-lg mx-auto min-h-screen flex flex-col">

        <!-- HEADER -->
        <header class="bg-dot-navy text-white p-4">
            <div class="flex justify-between items-start">
                <div>
                    <div class="flex items-center gap-2 mb-1">
                        <i class="fas fa-clock text-dot-yellow"></i>
                        <span class="text-[10px] font-bold tracking-widest text-dot-yellow">OFFLINE QUEUE</span>
                    </div>
                    <h1 class="text-xl font-bold tracking-tight">
                        Drafts & Pending Reports
                    </h1>
                    <p id="queueCount" class="text-xs text-slate-400 mt-1">Loading...</p>
                </div>
                <a href="index.html" class="w-10 h-10 border border-slate-600 flex items-center justify-center text-slate-400 hover:bg-slate-800 hover:text-white transition-colors" title="Back to Dashboard">
                    <i class="fas fa-arrow-left"></i>
                </a>
            </div>
        </header>

        <!-- DRAFTS LIST -->
        <section id="draftsList" class="px-4 py-4 flex-1">
            <!-- Content rendered by renderDrafts() -->
        </section>

        <!-- FOOTER -->
        <footer class="bg-dot-navy text-center py-3">
            <p class="text-[10px] text-slate-500 uppercase tracking-widest">
                <i class="fas fa-shield-alt mr-1"></i>
                DOT Compliant Field Documentation System
            </p>
        </footer>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="hidden fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
        <div class="bg-white max-w-sm w-full shadow-xl">
            <div class="bg-red-600 p-4">
                <div class="flex items-center gap-3 text-white">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3 class="font-bold uppercase tracking-wider">Delete Draft</h3>
                </div>
            </div>
            <div class="p-6">
                <p class="text-slate-700 mb-2">Are you sure you want to delete this draft?</p>
                <p id="deleteModalProject" class="font-bold text-slate-800 mb-4"></p>
                <p class="text-sm text-slate-500">This action cannot be undone.</p>
            </div>
            <div class="p-4 border-t border-slate-200 flex gap-3">
                <button onclick="closeDeleteModal()" class="flex-1 p-3 border-2 border-slate-300 text-slate-700 font-bold uppercase hover:bg-slate-50 transition-colors">
                    Cancel
                </button>
                <button id="confirmDeleteBtn" class="flex-1 p-3 bg-red-600 text-white font-bold uppercase hover:bg-red-700 transition-colors">
                    Delete
                </button>
            </div>
        </div>
    </div>

    <script>
        // ============ STORAGE KEYS ============
        const OFFLINE_QUEUE_KEY = 'fvp_offline_queue';

        // ============ STATE ============
        let pendingDeleteIndex = null;

        // ============ OFFLINE QUEUE MANAGEMENT ============
        function getOfflineQueue() {
            try {
                const stored = localStorage.getItem(OFFLINE_QUEUE_KEY);
                if (!stored) return { drafts: [] };
                const parsed = JSON.parse(stored);
                return parsed.drafts ? parsed : { drafts: [] };
            } catch (e) {
                console.error('[DRAFTS] Failed to parse offline queue:', e);
                return { drafts: [] };
            }
        }

        function saveOfflineQueue(queue) {
            try {
                localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(queue));
            } catch (e) {
                console.error('[DRAFTS] Failed to save offline queue:', e);
            }
        }

        function removeDraft(index) {
            const queue = getOfflineQueue();
            if (index >= 0 && index < queue.drafts.length) {
                queue.drafts.splice(index, 1);
                saveOfflineQueue(queue);
            }
        }

        function updateDraftError(index, errorMessage) {
            const queue = getOfflineQueue();
            if (index >= 0 && index < queue.drafts.length) {
                queue.drafts[index].status = 'sync_failed';
                queue.drafts[index].errorMessage = errorMessage;
                queue.drafts[index].lastSaved = new Date().toISOString();
                saveOfflineQueue(queue);
            }
        }

        // ============ UI HELPERS ============
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function formatDate(dateStr) {
            if (!dateStr) return 'Unknown date';
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
        }

        function formatTime(isoStr) {
            if (!isoStr) return '';
            const date = new Date(isoStr);
            return date.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        function getStatusBadge(status) {
            switch (status) {
                case 'draft':
                    return {
                        text: 'Draft',
                        bgColor: 'bg-dot-slate',
                        borderColor: 'border-dot-slate'
                    };
                case 'pending_sync':
                    return {
                        text: 'Pending Sync',
                        bgColor: 'bg-dot-orange',
                        borderColor: 'border-dot-orange'
                    };
                case 'sync_failed':
                    return {
                        text: 'Sync Failed',
                        bgColor: 'bg-red-600',
                        borderColor: 'border-red-600'
                    };
                default:
                    return {
                        text: status || 'Unknown',
                        bgColor: 'bg-slate-400',
                        borderColor: 'border-slate-400'
                    };
            }
        }

        function showToast(message, type = 'success') {
            const existing = document.querySelector('.toast-msg');
            if (existing) existing.remove();
            const colors = { success: 'bg-safety-green', warning: 'bg-dot-orange', error: 'bg-red-600', info: 'bg-dot-blue' };
            const icons = { success: 'fa-check', warning: 'fa-exclamation-triangle', error: 'fa-times-circle', info: 'fa-info-circle' };
            const toast = document.createElement('div');
            toast.className = `toast-msg fixed bottom-24 left-1/2 -translate-x-1/2 ${colors[type] || colors.success} text-white px-6 py-3 font-bold text-sm shadow-lg z-50 flex items-center gap-2 uppercase`;
            toast.innerHTML = `<i class="fas ${icons[type] || icons.success}"></i>${escapeHtml(message)}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============ RENDER FUNCTIONS ============
        function renderDrafts() {
            const queue = getOfflineQueue();
            const drafts = queue.drafts || [];
            const container = document.getElementById('draftsList');
            const countEl = document.getElementById('queueCount');

            // Update count
            if (drafts.length === 0) {
                countEl.textContent = 'No pending items';
            } else if (drafts.length === 1) {
                countEl.textContent = '1 pending item';
            } else {
                countEl.textContent = `${drafts.length} pending items`;
            }

            // Show sync banner if online and has pending items
            const syncBanner = document.getElementById('syncBanner');
            const hasSyncable = drafts.some(d => d.status === 'pending_sync' || d.status === 'sync_failed');
            if (navigator.onLine && hasSyncable) {
                syncBanner.classList.remove('hidden');
            } else {
                syncBanner.classList.add('hidden');
            }

            // Render empty state or drafts
            if (drafts.length === 0) {
                container.innerHTML = `
                    <div class="bg-white border-2 border-slate-200 p-8 text-center">
                        <div class="w-20 h-20 bg-slate-100 border-2 border-slate-300 flex items-center justify-center mx-auto mb-4">
                            <i class="fas fa-inbox text-slate-400 text-3xl"></i>
                        </div>
                        <p class="text-lg font-bold text-slate-700 mb-2">No Drafts or Pending Reports</p>
                        <p class="text-sm text-slate-500 mb-6">All your reports are synced and up to date.</p>
                        <a href="index.html" class="inline-block bg-dot-navy hover:bg-dot-blue text-white px-6 py-3 font-bold uppercase tracking-wide transition-colors">
                            <i class="fas fa-arrow-left mr-2"></i>Back to Dashboard
                        </a>
                    </div>
                `;
                return;
            }

            // Render draft cards
            container.innerHTML = drafts.map((draft, index) => {
                const status = getStatusBadge(draft.status);
                const showRetry = draft.status === 'pending_sync' || draft.status === 'sync_failed';

                return `
                    <div class="bg-white border-l-4 ${status.borderColor} p-4 mb-4">
                        <div class="flex items-start justify-between mb-3">
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="text-[10px] font-bold ${status.bgColor} text-white px-2 py-0.5 uppercase">${status.text}</span>
                                    <span class="text-[10px] font-bold text-slate-400 uppercase">${draft.captureMode || 'guided'} mode</span>
                                </div>
                                <p class="font-bold text-slate-800 truncate">${escapeHtml(draft.projectName || 'Unknown Project')}</p>
                                <p class="text-sm text-slate-600">${formatDate(draft.reportDate)}</p>
                            </div>
                            <div class="text-right shrink-0 ml-4">
                                <p class="text-xs text-slate-400">Last saved</p>
                                <p class="text-sm text-slate-600">${formatTime(draft.lastSaved)}</p>
                            </div>
                        </div>

                        ${draft.errorMessage ? `
                        <div class="bg-red-50 border border-red-200 p-3 mb-3">
                            <div class="flex items-start gap-2">
                                <i class="fas fa-exclamation-circle text-red-600 mt-0.5"></i>
                                <p class="text-sm text-red-700">${escapeHtml(draft.errorMessage)}</p>
                            </div>
                        </div>
                        ` : ''}

                        <div class="flex gap-2">
                            <button onclick="continueEditing(${index})" class="flex-1 p-3 bg-dot-navy hover:bg-dot-blue text-white text-sm font-bold uppercase transition-colors">
                                <i class="fas fa-edit mr-1"></i>Continue
                            </button>
                            ${showRetry ? `
                            <button onclick="retrySync(${index})" class="flex-1 p-3 bg-safety-green hover:bg-green-700 text-white text-sm font-bold uppercase transition-colors">
                                <i class="fas fa-sync-alt mr-1"></i>Retry
                            </button>
                            ` : ''}
                            <button onclick="confirmDelete(${index})" class="p-3 border-2 border-red-300 text-red-600 hover:bg-red-50 transition-colors">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ============ ACTIONS ============
        function continueEditing(index) {
            const queue = getOfflineQueue();
            const draft = queue.drafts[index];

            if (!draft) {
                showToast('Draft not found', 'error');
                return;
            }

            // Set active project
            if (draft.projectId) {
                localStorage.setItem(ACTIVE_PROJECT_KEY, draft.projectId);
            }

            // Store the draft data for quick-interview to load
            // We'll use the existing QUICK_INTERVIEW_STORAGE_KEY format
            const quickInterviewData = {
                projectId: draft.projectId,
                reportDate: draft.reportDate,
                captureMode: draft.captureMode,
                lastSaved: draft.lastSaved,
                ...draft.data
            };

            localStorage.setItem('fvp_quick_interview_draft', JSON.stringify(quickInterviewData));

            // Navigate to quick-interview
            window.location.href = 'quick-interview.html';
        }

        async function retrySync(index) {
            const queue = getOfflineQueue();
            const draft = queue.drafts[index];

            if (!draft) {
                showToast('Draft not found', 'error');
                return;
            }

            if (!navigator.onLine) {
                showToast("You're offline. Connect to sync.", 'warning');
                return;
            }

            // Show loading state
            showToast('Syncing report...', 'info');

            try {
                // Attempt to sync via the same flow as FINISH
                const result = await syncDraft(draft, index);

                if (result.success) {
                    // Remove from queue
                    removeDraft(index);
                    showToast('Report synced successfully!', 'success');

                    // Redirect to report.html to view the synced report
                    setTimeout(() => {
                        window.location.href = 'report.html';
                    }, 1000);
                } else {
                    // Update error message
                    updateDraftError(index, result.error || 'Sync failed. Please try again.');
                    renderDrafts();
                    showToast('Sync failed', 'error');
                }
            } catch (error) {
                console.error('[DRAFTS] Sync error:', error);
                updateDraftError(index, error.message || 'An unexpected error occurred');
                renderDrafts();
                showToast('Sync failed', 'error');
            }
        }

        async function syncDraft(draft, index) {
            try {
                // The draft contains all the data needed to complete the FINISH flow
                // This includes the payload for AI processing

                // First, ensure the report exists in Supabase
                const reportData = draft.data;
                if (!reportData) {
                    return { success: false, error: 'No report data found in draft' };
                }

                // Set active project for the sync
                if (draft.projectId) {
                    localStorage.setItem(ACTIVE_PROJECT_KEY, draft.projectId);
                }

                // Check if report already exists in Supabase
                const { data: existingReport, error: fetchError } = await supabaseClient
                    .from('reports')
                    .select('id, status')
                    .eq('project_id', draft.projectId)
                    .eq('report_date', draft.reportDate)
                    .single();

                let reportId;
                if (existingReport) {
                    reportId = existingReport.id;
                } else {
                    // Create the report in Supabase
                    const { data: newReport, error: createError } = await supabaseClient
                        .from('reports')
                        .insert({
                            project_id: draft.projectId,
                            report_date: draft.reportDate,
                            status: 'pending_refine',
                            raw_capture: reportData
                        })
                        .select('id')
                        .single();

                    if (createError) {
                        return { success: false, error: 'Failed to create report: ' + createError.message };
                    }
                    reportId = newReport.id;
                }

                // Build payload for AI processing
                const payload = draft.payload || buildPayloadFromDraft(draft);

                // Call the AI processing webhook
                const webhookUrl = 'https://advidere.app.n8n.cloud/webhook/fieldvoice-refine-v6';
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    return { success: false, error: `Webhook error: ${response.status} - ${errorText}` };
                }

                const result = await response.json();

                // Save AI response to report
                if (result.aiGenerated) {
                    const { error: updateError } = await supabaseClient
                        .from('reports')
                        .update({
                            status: 'refined',
                            ai_generated: result.aiGenerated,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', reportId);

                    if (updateError) {
                        return { success: false, error: 'Failed to save AI response: ' + updateError.message };
                    }
                }

                return { success: true, reportId };
            } catch (error) {
                console.error('[DRAFTS] Sync error:', error);
                return { success: false, error: error.message || 'Network error during sync' };
            }
        }

        function buildPayloadFromDraft(draft) {
            // Build payload matching quick-interview.html's buildProcessPayload() structure
            const data = draft.data || {};
            const reportKey = `${draft.projectId}_${draft.reportDate}`;

            return {
                reportId: reportKey,
                captureMode: draft.captureMode || 'guided',

                projectContext: {
                    projectId: draft.projectId || null,
                    projectName: draft.projectName || '',
                    noabProjectNo: data.project?.noabProjectNo || '',
                    location: data.project?.location || '',
                    engineer: data.project?.engineer || '',
                    primeContractor: data.project?.primeContractor || '',
                    contractors: data.project?.contractors || [],
                    equipment: data.project?.equipment || []
                },

                fieldNotes: draft.captureMode === 'minimal'
                    ? { freeformNotes: data.fieldNotes?.freeformNotes || '' }
                    : {
                        workSummary: data.guidedNotes?.workSummary || '',
                        issues: data.guidedNotes?.issues || '',
                        safety: data.guidedNotes?.safety || ''
                      },

                weather: data.overview?.weather || data.weather || {},

                photos: (data.photos || []).map(p => ({
                    id: p.id,
                    caption: p.caption || '',
                    timestamp: p.timestamp,
                    date: p.date,
                    time: p.time,
                    gps: p.gps
                })),

                reportDate: draft.reportDate || data.overview?.date || new Date().toLocaleDateString(),
                inspectorName: data.overview?.completedBy || ''
            };
        }

        async function syncAllPending() {
            const queue = getOfflineQueue();
            const syncable = queue.drafts.filter(d => d.status === 'pending_sync' || d.status === 'sync_failed');

            if (syncable.length === 0) {
                showToast('No items to sync', 'info');
                return;
            }

            if (!navigator.onLine) {
                showToast("You're offline. Connect to sync.", 'warning');
                return;
            }

            showToast(`Syncing ${syncable.length} report(s)...`, 'info');

            let successCount = 0;
            let failCount = 0;

            // Sync each item (process in reverse order to handle index shifts)
            for (let i = queue.drafts.length - 1; i >= 0; i--) {
                const draft = queue.drafts[i];
                if (draft.status !== 'pending_sync' && draft.status !== 'sync_failed') continue;

                try {
                    const result = await syncDraft(draft, i);
                    if (result.success) {
                        removeDraft(i);
                        successCount++;
                    } else {
                        updateDraftError(i, result.error);
                        failCount++;
                    }
                } catch (error) {
                    updateDraftError(i, error.message);
                    failCount++;
                }
            }

            renderDrafts();

            if (failCount === 0) {
                showToast(`${successCount} report(s) synced!`, 'success');
                if (successCount > 0) {
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
            } else {
                showToast(`${successCount} synced, ${failCount} failed`, failCount > 0 ? 'warning' : 'success');
            }
        }

        // ============ DELETE MODAL ============
        function confirmDelete(index) {
            const queue = getOfflineQueue();
            const draft = queue.drafts[index];

            if (!draft) return;

            pendingDeleteIndex = index;
            document.getElementById('deleteModalProject').textContent = draft.projectName || 'Unknown Project';
            document.getElementById('deleteModal').classList.remove('hidden');

            // Set up confirm button
            document.getElementById('confirmDeleteBtn').onclick = () => {
                deleteDraft(pendingDeleteIndex);
                closeDeleteModal();
            };
        }

        function closeDeleteModal() {
            document.getElementById('deleteModal').classList.add('hidden');
            pendingDeleteIndex = null;
        }

        function deleteDraft(index) {
            removeDraft(index);
            renderDrafts();
            showToast('Draft deleted', 'success');
        }

        // ============ INIT ============
        document.addEventListener('DOMContentLoaded', () => {
            renderDrafts();
        });
    </script>

    <!-- Offline Banner -->
    <div id="offline-banner" class="fixed top-0 left-0 right-0 bg-yellow-500 text-yellow-900 text-center py-2 px-4 font-bold text-sm z-[9999] transform -translate-y-full transition-transform duration-300" style="display: none;">
        <i class="fas fa-wifi-slash mr-2"></i>You are offline
    </div>

    <!-- Initialize PWA features with page-specific handlers -->
    <script>
        initPWA({
            onOnline: () => renderDrafts(),
            onOffline: () => {
                document.getElementById('syncBanner').classList.add('hidden');
                showToast("You're offline", 'warning');
            }
        });
    </script>
</body>
</html>
